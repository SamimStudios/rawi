// src/hooks/useTemplates.ts
// Templates + template_nodes helpers with version-awareness and safe replace-save.

import { supabase } from '@/integrations/supabase/client';

export type NodeType = 'form' | 'group' | 'media';

export interface TemplateRow {
  id: string;
  name: string;
  category: string;
  active: boolean;
  current_version: number;
  meta?: any;
  created_at?: string;
  updated_at?: string;
}

export interface TemplateNodeRow {
  template_id: string;
  version: number;
  idx: number; // 1..N per (template_id,version,parent_addr)
  node_type: NodeType;
  path: string; // single label
  parent_addr: string | null; // ltree or null for root
  addr?: string | null; // generated by DB
  library_id: string;

  // optional columns
  dependencies?: string[] | null; // ltree[]
  arrangeable?: boolean;
  removable?: boolean;
  content_override?: any | null;
  payload_validate_override?: any | null;
  payload_generate_override?: any | null;
  validate_n8n_id_override?: string | null;
  generate_n8n_id_override?: string | null;

  created_at?: string;
  updated_at?: string;
}

export interface LibraryRow {
  id: string;
  node_type: NodeType;
  content: any;
  active: boolean;
  version: number;
}

export const isValidPathLabel = (p: string) => /^[a-z][a-z0-9_]*$/.test(p);

export async function fetchActiveTemplates(): Promise<TemplateRow[]> {
  const { data, error } = await supabase
    .schema('app')
    .from('templates')
    .select('id,name,category,active,current_version,meta,created_at,updated_at')
    .eq('active', true)
    .order('created_at', { ascending: false });
  if (error) throw error;
  return data ?? [];
}

export async function fetchTemplateById(id: string): Promise<TemplateRow | null> {
  const { data, error } = await supabase
    .schema('app')
    .from('templates')
    .select('id,name,category,active,current_version,meta,created_at,updated_at')
    .eq('id', id)
    .maybeSingle();
  if (error) throw error;
  return data ?? null;
}

export async function fetchTemplateNodes(templateId: string, version: number): Promise<TemplateNodeRow[]> {
  const { data, error } = await supabase
    .schema('app')
    .from('template_nodes')
    .select('*')
    .eq('template_id', templateId)
    .eq('version', version)
    .order('parent_addr', { ascending: true, nullsFirst: true })
    .order('idx', { ascending: true });
  if (error) throw error;
  return (data ?? []) as TemplateNodeRow[];
}

export async function loadLibraryIndex(): Promise<Map<string, LibraryRow>> {
  const { data, error } = await supabase
    .schema('app')
    .from('node_library')
    .select('id,node_type,content,active,version')
    .eq('active', true);
  if (error) throw error;
  const map = new Map<string, LibraryRow>();
  (data ?? []).forEach((r: any) => map.set(r.id, r as LibraryRow));
  return map;
}

// Ensure anchor libraries exist (idempotent)
export async function ensureGroupAnchors(): Promise<void> {
  const anchors = [
    { id: 'lib_group_instances_anchor', node_type: 'group', content: { kind: 'Group' }, active: true, version: 1 },
    { id: 'lib_group_instance_anchor',  node_type: 'group', content: { kind: 'Group' }, active: true, version: 1 }
  ];
  const { error } = await supabase
    .schema('app')
    .from('node_library')
    .upsert(anchors as any, { onConflict: 'id' });
  if (error) throw error;
}

// Normalize idx to 1..N per (template_id,version,parent_addr), stable by (idx,path)
export function normalizeNodesForSave(nodes: TemplateNodeRow[], version: number): TemplateNodeRow[] {
  const groups = new Map<string, TemplateNodeRow[]>();
  for (const n of nodes) {
    const k = n.parent_addr ?? '__ROOT__';
    if (!groups.has(k)) groups.set(k, []);
    groups.get(k)!.push(n);
  }
  const out: TemplateNodeRow[] = [];
  for (const [, arr] of groups.entries()) {
    arr.sort((a, b) => (a.idx - b.idx) || a.path.localeCompare(b.path));
    arr.forEach((n, i) => out.push({ ...n, version, idx: i + 1 }));
  }
  return out;
}

// "Replace save": delete rows that are no longer present, then upsert the provided set (without addr)
// keep the name your builder calls:
export async function saveTemplateNodes(rows: TemplateNodeRow[]): Promise<void> {
  if (!rows?.length) return;

  // sanity: every row must carry template_id + version
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i] as any;
    if (!r.template_id || typeof r.template_id !== 'string') {
      console.error('Row missing template_id at index', i, r);
      throw new Error(`Row[${i}] missing template_id`);
    }
    if (typeof r.version !== 'number') {
      console.error('Row missing version at index', i, r);
      throw new Error(`Row[${i}] missing version`);
    }
  }

  // map to DB columns, DO NOT drop template_id/version
  const payload = rows.map(r => ({
    template_id: r.template_id,
    version: r.version,
    idx: r.idx ?? 999999,
    node_type: r.node_type,
    path: r.path,
    parent_addr: r.parent_addr ?? null,
    library_id: r.library_id,
    dependencies: r.dependencies ?? [],
    arrangeable: r.arrangeable ?? false,
    removable: r.removable ?? false,
    content_override: r.content_override ?? null,
    payload_validate_override: r.payload_validate_override ?? null,
    payload_generate_override: r.payload_generate_override ?? null,
    validate_n8n_id_override: r.validate_n8n_id_override ?? null,
    generate_n8n_id_override: r.generate_n8n_id_override ?? null,
  }));

  // upsert by (template_id,version,addr); addr is generated by DB
  const { error } = await supabase
    .schema('app')
    .from('template_nodes')
    .upsert(payload, { onConflict: 'template_id,version,addr' });

  if (error) throw error;
}


// Hook wrapper (keeps your existing import surface)
export function useTemplates() {
  return {
    fetchTemplates: fetchActiveTemplates,
    fetchTemplateById,
    fetchTemplateNodes,
    loadLibraryIndex,
    ensureGroupAnchors,
    saveTemplateNodes: replaceSaveTemplateNodes, // <-- replace-save semantics
    normalizeNodesForSave,
    isValidPathLabel
  };
}
