// src/hooks/useTemplates.ts
// Templates + template_nodes helpers with version-awareness and safe replace-save.

import { supabase } from '@/integrations/supabase/client';

export type NodeType = 'form' | 'group' | 'media';

export interface TemplateRow {
  id: string;
  name: string;
  category: string;
  active: boolean;
  current_version: number;
  meta?: any;
  created_at?: string;
  updated_at?: string;
}

export interface TemplateNodeRow {
  template_id: string;
  version: number;
  idx: number; // 1..N per (template_id,version,parent_addr)
  node_type: NodeType;
  path: string; // single label
  parent_addr: string | null; // ltree or null for root
  addr?: string | null; // generated by DB
  library_id: string;

  // optional columns
  dependencies?: string[] | null; // ltree[]
  arrangeable?: boolean;
  removable?: boolean;
  content_override?: any | null;
  payload_validate_override?: any | null;
  payload_generate_override?: any | null;
  validate_n8n_id_override?: string | null;
  generate_n8n_id_override?: string | null;

  created_at?: string;
  updated_at?: string;
}

export interface LibraryRow {
  id: string;
  node_type: NodeType;
  content: any;
  active: boolean;
  version: number;
}

export const isValidPathLabel = (p: string) => /^[a-z][a-z0-9_]*$/.test(p);

export async function fetchActiveTemplates(): Promise<TemplateRow[]> {
  const { data, error } = await supabase
    .schema('app' as any)
    .from('templates')
    .select('id,name,category,active,current_version,meta,created_at,updated_at')
    .order('created_at', { ascending: false });
  if (error) throw error;
  return data ?? [];
}

export async function fetchTemplateById(id: string): Promise<TemplateRow | null> {
  const { data, error } = await supabase
    .schema('app' as any)
    .from('templates')
    .select('id,name,category,active,current_version,meta,created_at,updated_at')
    .eq('id', id)
    .maybeSingle();
  if (error) throw error;
  return data ?? null;
}

export async function fetchTemplateNodes(templateId: string, version: number): Promise<TemplateNodeRow[]> {
  const { data, error } = await supabase
    .schema('app' as any)
    .from('template_nodes')
    .select('*')
    .eq('template_id', templateId)
    .eq('version', version)
    .order('parent_addr', { ascending: true, nullsFirst: true })
    .order('idx', { ascending: true });
  if (error) throw error;
  return (data ?? []) as TemplateNodeRow[];
}

export async function loadLibraryIndex(): Promise<Map<string, LibraryRow>> {
  const { data, error } = await supabase
    .schema('app' as any)
    .from('node_library')
    .select('id,node_type,content,active,version')
    .eq('active', true);
  if (error) throw error;
  const map = new Map<string, LibraryRow>();
  (data ?? []).forEach((r: any) => map.set(r.id, r as LibraryRow));
  return map;
}

// Ensure anchor libraries exist (idempotent)
export async function ensureGroupAnchors(): Promise<void> {
  const anchors = [
    { id: 'lib_group_instances_anchor', node_type: 'group', content: { kind: 'Group' }, active: true, version: 1 },
    { id: 'lib_group_instance_anchor',  node_type: 'group', content: { kind: 'Group' }, active: true, version: 1 }
  ];
  const { error } = await supabase
    .schema('app' as any)
    .from('node_library')
    .upsert(anchors as any, { onConflict: 'id' });
  if (error) throw error;
}

// Normalize idx to 1..N per (template_id,version,parent_addr), stable by (idx,path)
export function normalizeNodesForSave(nodes: TemplateNodeRow[], version: number): TemplateNodeRow[] {
  const groups = new Map<string, TemplateNodeRow[]>();
  for (const n of nodes) {
    const k = n.parent_addr ?? '__ROOT__';
    if (!groups.has(k)) groups.set(k, []);
    groups.get(k)!.push(n);
  }
  const out: TemplateNodeRow[] = [];
  for (const [, arr] of groups.entries()) {
    arr.sort((a, b) => (a.idx - b.idx) || a.path.localeCompare(b.path));
    arr.forEach((n, i) => out.push({ ...n, version, idx: i + 1 }));
  }
  return out;
}

// "Replace save": delete rows that are no longer present, then upsert the provided set (without addr)
export async function createTemplate(name: string, category: string): Promise<string> {
  const { data, error } = await supabase
    .schema('app' as any)
    .from('templates')
    .insert({ name, category, active: true, current_version: 1 })
    .select('id')
    .single();
  if (error) throw error;
  return data.id;
}

export async function replaceSaveTemplateNodes(allRows: TemplateNodeRow[]): Promise<void> {
  if (!allRows.length) return;
  const { template_id, version } = allRows[0];

  // 1) load existing addrs
  const { data: existing, error: exErr } = await supabase
    .schema('app' as any)
    .from('template_nodes')
    .select('addr')
    .eq('template_id', template_id)
    .eq('version', version);
  if (exErr) throw exErr;

  const keepAddrs = new Set(
    allRows
      .map(r => r.addr)
      .filter(Boolean) as string[]
  );

  const toDelete = (existing ?? [])
    .map(r => (r as any).addr as string)
    .filter(addr => !keepAddrs.has(addr));

  if (toDelete.length) {
    const { error: delErr } = await supabase
      .schema('app' as any)
      .from('template_nodes')
      .delete()
      .eq('template_id', template_id)
      .eq('version', version)
      .in('addr', toDelete);
    if (delErr) throw delErr;
  }

  // 2) upsert without addr, ensure non-nullables
  const payload = allRows.map(({ addr, ...rest }) => ({
    ...rest,
    dependencies: (rest.dependencies ?? []),
    arrangeable: rest.arrangeable ?? true,
    removable: rest.removable ?? true,
  }));
  const { error: upErr } = await supabase
    .schema('app' as any)
    .from('template_nodes')
    .upsert(payload, { onConflict: 'template_id,version,addr' });
  if (upErr) throw upErr;
}

// Hook wrapper (keeps your existing import surface)
export function useTemplates() {
  return {
    fetchTemplates: fetchActiveTemplates,
    fetchTemplateById,
    fetchTemplateNodes,
    loadLibraryIndex,
    ensureGroupAnchors,
    createTemplate,
    saveTemplateNodes: replaceSaveTemplateNodes,
    normalizeNodesForSave,
    isValidPathLabel
  };
}
