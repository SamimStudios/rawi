// src/hooks/useTemplates.ts
// Templates + template_nodes helpers with version-awareness and safe replace-save.

import { supabase } from '@/integrations/supabase/client';

export type NodeType = 'form' | 'group' | 'media';

export interface TemplateRow {
  id: string;
  name: string;
  category: string;
  active: boolean;
  current_version: number;
  meta?: any;
  created_at?: string;
  updated_at?: string;
}

export interface TemplateNodeRow {
  template_id: string;
  version: number;
  idx: number; // 1..N per (template_id,version,parent_addr)
  node_type: NodeType;
  path: string; // single label
  parent_addr: string | null; // ltree or null for root
  addr?: string | null; // generated by DB
  library_id: string;

  // optional columns
  dependencies?: string[] | null; // ltree[]
  arrangeable?: boolean;
  removable?: boolean;
  content_override?: any | null;
  payload_validate_override?: any | null;
  payload_generate_override?: any | null;
  validate_n8n_id_override?: string | null;
  generate_n8n_id_override?: string | null;

  created_at?: string;
  updated_at?: string;
}

export interface LibraryRow {
  id: string;
  node_type: NodeType;
  content: any;
  active: boolean;
  version: number;
}

export const isValidPathLabel = (p: string) => /^[a-z][a-z0-9_]*$/.test(p);

export async function fetchActiveTemplates(): Promise<TemplateRow[]> {
  const { data, error } = await supabase
    .schema('app')
    .from('templates')
    .select('id,name,category,active,current_version,meta,created_at,updated_at')
    .eq('active', true)
    .order('created_at', { ascending: false });
  if (error) throw error;
  return data ?? [];
}

export async function fetchTemplateById(id: string): Promise<TemplateRow | null> {
  const { data, error } = await supabase
    .schema('app')
    .from('templates')
    .select('id,name,category,active,current_version,meta,created_at,updated_at')
    .eq('id', id)
    .maybeSingle();
  if (error) throw error;
  return data ?? null;
}

export async function fetchTemplateNodes(templateId: string, version: number): Promise<TemplateNodeRow[]> {
  const { data, error } = await supabase
    .schema('app')
    .from('template_nodes')
    .select('*')
    .eq('template_id', templateId)
    .eq('version', version)
    .order('parent_addr', { ascending: true, nullsFirst: true })
    .order('idx', { ascending: true });
  if (error) throw error;
  return (data ?? []) as TemplateNodeRow[];
}

export async function loadLibraryIndex(): Promise<Map<string, LibraryRow>> {
  const { data, error } = await supabase
    .schema('app')
    .from('node_library')
    .select('id,node_type,content,active,version')
    .eq('active', true);
  if (error) throw error;
  const map = new Map<string, LibraryRow>();
  (data ?? []).forEach((r: any) => map.set(r.id, r as LibraryRow));
  return map;
}

// Ensure anchor libraries exist (idempotent)
export async function ensureGroupAnchors(): Promise<void> {
  const anchors = [
    { id: 'lib_group_instances_anchor', node_type: 'group', content: { kind: 'Group' }, active: true, version: 1 },
    { id: 'lib_group_instance_anchor',  node_type: 'group', content: { kind: 'Group' }, active: true, version: 1 }
  ];
  const { error } = await supabase
    .schema('app')
    .from('node_library')
    .upsert(anchors as any, { onConflict: 'id' });
  if (error) throw error;
}

// Normalize idx to 1..N per (template_id,version,parent_addr), stable by (idx,path)
export function normalizeNodesForSave(nodes: TemplateNodeRow[], version: number): TemplateNodeRow[] {
  const groups = new Map<string, TemplateNodeRow[]>();
  for (const n of nodes) {
    const k = n.parent_addr ?? '__ROOT__';
    if (!groups.has(k)) groups.set(k, []);
    groups.get(k)!.push(n);
  }
  const out: TemplateNodeRow[] = [];
  for (const [, arr] of groups.entries()) {
    arr.sort((a, b) => (a.idx - b.idx) || a.path.localeCompare(b.path));
    arr.forEach((n, i) => out.push({ ...n, version, idx: i + 1 }));
  }
  return out;
}

// "Replace save": delete old nodes and insert new ones in a transaction
export async function replaceSaveTemplateNodes(allRows: TemplateNodeRow[]): Promise<void> {
  if (!allRows.length) return;
  const { template_id, version } = allRows[0];

  // Step 1: Delete ALL existing nodes for this template_id + version
  const { error: delErr } = await supabase
    .schema('app')
    .from('template_nodes')
    .delete()
    .eq('template_id', template_id)
    .eq('version', version);
  
  if (delErr) throw delErr;

  // Step 2: Prepare payload - remove addr (DB-generated) and created_at/updated_at
  const payload = allRows.map(({ addr, created_at, updated_at, ...rest }) => rest);

  // Step 3: Insert new nodes (addr will be auto-generated by DB)
  const { error: insErr } = await supabase
    .schema('app')
    .from('template_nodes')
    .insert(payload);
  
  if (insErr) throw insErr;
}

// Hook wrapper (keeps your existing import surface)
export function useTemplates() {
  return {
    fetchTemplates: fetchActiveTemplates,
    fetchTemplateById,
    fetchTemplateNodes,
    loadLibraryIndex,
    ensureGroupAnchors,
    saveTemplateNodes: replaceSaveTemplateNodes,
    normalizeNodesForSave,
    isValidPathLabel
  };
}

// Note: Make sure to also fix the TemplateBuilder.tsx parentOptions useMemo
// Change:
//   const groupAddrs = nodes?.filter(...).map(...)
// To:
//   const groupAddrs = (nodes ?? []).filter(...).map(...)
